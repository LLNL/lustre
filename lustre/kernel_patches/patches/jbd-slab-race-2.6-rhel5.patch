kmem_cache_create: duplicate cache jbd_4k

The jbd slab cache creation/deletion is racey.  If multiple jbd based
filesystems are mounted concurrently, and there are no other jbd based
filesystems already mounted.  Then we can race creating the slab caches
since jbd_slab[] is not locked.  This is not commonly observed because
typically /root is mounted early with a jbd based filesystem making the
race impossible.  On our diskless systems /root does not use the jbd
but we do have attached storage which does, and which is mounted in
parallel.  Basically our setup is similiar to what may be found in a
NAS style appliance.

This patch wraps all modifications to jbd_slab[] in the jbd_slab_lock
to prevent this above race.

LLNL Bug 291
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>

Index: linux+rh+chaos/fs/jbd/journal.c
===================================================================
--- linux+rh+chaos.orig/fs/jbd/journal.c
+++ linux+rh+chaos/fs/jbd/journal.c
@@ -2016,20 +2020,27 @@ static int journal_create_jbd_slab(size_
 
 void * jbd_slab_alloc(size_t size, gfp_t flags)
 {
+	void *ptr;
 	int idx;
 
+	down_read(&jbd_slab_lock);
 	idx = JBD_SLAB_INDEX(size);
 	BUG_ON(jbd_slab[idx] == NULL);
-	return kmem_cache_alloc(jbd_slab[idx], flags | __GFP_NOFAIL);
+	ptr = kmem_cache_alloc(jbd_slab[idx], flags | __GFP_NOFAIL);
+	up_read(&jbd_slab_lock);
+
+	return ptr;
 }
 
 void jbd_slab_free(void *ptr,  size_t size)
 {
 	int idx;
 
+	down_read(&jbd_slab_lock);
 	idx = JBD_SLAB_INDEX(size);
 	BUG_ON(jbd_slab[idx] == NULL);
 	kmem_cache_free(jbd_slab[idx], ptr);
+	up_read(&jbd_slab_lock);
 }
 
 /*

